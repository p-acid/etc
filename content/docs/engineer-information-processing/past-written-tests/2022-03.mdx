---
title: "2022년 3월"
description: "2022년 3월 정보처리기사 기출문제 풀이 후 작성한 오답노트입니다."
icon: NotebookPen
---

## 요약

---

| 과목 번호 | 과목명               | 문항수 | 맞힌 수 | 점수 | 판정     |
| --------- | -------------------- | ------ | ------- | ---- | -------- |
| 1과목     | 소프트웨어 설계      | 20개   | 15개    | 75점 | 통과     |
| 2과목     | 소프트웨어 개발      | 20개   | 11개    | 55점 | 통과     |
| 3과목     | 데이터베이스 구축    | 20개   | 11개    | 55점 | 통과     |
| 4과목     | 프로그래밍 언어 활용 | 20개   | 9개     | 45점 | 통과     |
| 5과목     | 정보시스템 구축관리  | 20개   | 5개     | 25점 | **과락** |

| 총 문항수 | 총 맞힌 수 | 총점 | 판정       |
| --------- | ---------- | ---- | ---------- |
| 100개     | 51개       | 51점 | **불합격** |

- 아예 풀지 못하는 문제는 찍지 않고 알지 못함을 선택
- 이전 복습으로 2, 3, 4과목의 평균 점수는 상승한 듯 보임
- 이전에 5과목 점수가 잘 나온건 운의 영역이 있었던 것 같음
- 5과목은 넓고 얕게 공부하는 방식 적용하기

<br />

## 1과목

---

### 5. 설계 기법

<Callout type="error">
  상향식 설계는 **최하위 수준에서 각각의 모듈들을 상세하게 설계**하고 이러한
  모듈이 완성되면 전체적으로 이들을 결합하여 설계하는 방식으로 **인터페이스가
  이미 성립되어 있어야지 기능 추가**가 쉽다.
</Callout>

- **하향식 통합 테스트(Top Down Integration Test)**
  - 깊이 우선 통합법, 넓이 우선 통합법을 사용한다.
  - 테스트 초기 부터 사용자에게 시스템 구조를 보여줄 수 있다.
  - 상위 모듈에서 tc를 사용하기 어려우며, 하위 모듈 방향으로 통합하면서 테스트하는 기법이다.
- **상향식 통합 테스트(Bottom Up Integration Test)**
  - 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트 하는 방법이다.
  - 가장 하위 단계의 모듈부터 통합 및 테스트가 수행되므로 스텁은 필요하지 않다.
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(cluster)는 필요하다.

<br />

### 11. UML 다이어그램

<Callout type="error">
  순차(시퀀스, sequence) 다이어그램은 **동적 다이어그램**에 해당한다.
</Callout>

- **정적 다이어그램(클객컴배복패)**
  - 클래스 다이어그램: 클래스와 클래스 간의 관계를 표현하여 시스템의 구조를 정의함.
  - 객체 다이어그램: 클래스 다이어그램을 기반으로 객체 간의 실제 인스턴스 관계를 표현함.
  - 컴포넌트 다이어그램: 시스템을 구성하는 컴포넌트 간의 연결 및 의존 관계를 표현함.
  - 배치 다이어그램: 하드웨어 노드와 그 위에 배포된 소프트웨어 구성 요소를 표현함.
  - 패키지 다이어그램: 관련된 클래스나 요소들을 논리적인 단위인 패키지로 묶어 표현함.
  - 복합 구조 다이어그램: 클래스 내부 구성과 구성 요소 간의 연결 구조를 표현함.
- **동적 다이어그램**
  - 시퀀스 다이어그램: 시간 흐름에 따라 객체 간의 메시지 교환 순서를 표현함.
  - 커뮤니케이션 다이어그램: 객체 간 메시지 흐름을 구조적인 관계 중심으로 표현함.
  - 활동 다이어그램: 프로세스나 워크플로우의 흐름을 순서대로 표현함.
  - 상태 다이어그램: 객체가 이벤트에 따라 상태가 어떻게 변화하는지를 표현함.
  - 타이밍 다이어그램: 시간에 따른 객체 상태나 메시지의 정밀한 타이밍을 표현함.

<br />

### 14. GoF(Gangs of Four) 디자인 패턴

<Callout>생성 패턴에 해당하는 것은 **추상 팩토리 패턴**이다.</Callout>

- 생성 패턴
  - 추상팩토리(Abstract Factory)
  - 빌더(Builder)
  - 팩토리메서드(FactoryMethod)
  - 프로토타입(Prototype)
  - 싱글톤(Singleton)
- 구조 패턴
  - 어댑터(Adapter)
  - 브리지(Bridge)
  - 컴포지트(Composite)
  - 데코레이터(Decorator)
  - 파사드(Facade)
  - 플라이웨이트(Flyweight)
  - 프록시(Proxy)
- 행위 패턴
  - 책임 연쇄(Chain of Responsibility)
  - 커맨드(Command)
  - 인터프리터(InterPreter)
  - 이터레이터(Iterator)
  - 중재자(Mediator)
  - 메멘토(Memento)
  - 옵서버(Observer)
  - 상태(State)
  - 전략(Strategy)
  - 템플릿메서드(Template Method)
  - 방문자(Visitor)

<br />

### 15. 소프트웨어 아키텍처 설계

<Callout title="아키텍처 패턴">
  아키텍처 설계 시 발생하는 문제들을 해결하기 위해 미리 만들어 놓은 해결
  방식이다.
</Callout>

1. 설계 목표 설정
2. 시스템 타입 결정
3. 아키텍처 패턴 적용(스타일 적용 및 커스터마이즈)
4. 서브시스템 구체화(서브시스템의 기능, 인터페이스 동작 작성)
5. 검토(아키텍쳐 설계 검토)

<br />

### 19. FEP

<Callout title="FEP(Front-End Processor)">
  입력되는 데이터를 **컴퓨터의 프로세서가 처리하기 전에 미리 처리**하여
  프로세서가 차지하는 시간을 줄여주는 **프로그램이나 하드웨어**
</Callout>

- **EAI(Enterprise Application Integration)**: 기업 내 여러 이기종 시스템이나 애플리케이션을 통합하여 데이터와 프로세스를 연동하는 기술
- **GPL(General Public License)**: 자유 소프트웨어 재배포와 수정이 가능한 오픈소스 라이선스의 대표 유형
- **Duplexing**: 데이터 통신에서 송신과 수신이 가능한 방식으로, 전이중(Full)과 반이중(Half) 방식이 있음

<br />

## 2과목

---

### 22. 테스트 드라이버

> 단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?

<Callout title="테스트 드라이버(Test Driver)">
  단위 테스트에서 **테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를
  전달하는 가상의 모듈**로 **상향식 테스트**에 필요한 것
</Callout>

<Callout type="warn">
  테스트 스텁은 **하향식**이고 테스트 드라이버는 **상향식**이다.
</Callout>

- **테스트 스텁**: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
- **테스트 슈트**: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
- **테스트 케이스**: 사용자의 요구사항을 정확히 준수했는지 확인하기 위한 입력 값, 실행조건, 기대결과 등으로 만들어진 테스트 항목의 명세서

<br />

### 23. 스택

> 스택에 대한 내용으로 옳은 것은?

<Callout>스택은 **LIFO 방식**으로 처리된다.</Callout>

1. FIFO 방식으로 처리된다. → **큐(Queue)**
2. 순서 리스트의 뒤(Rear)에서 노드가 삽입되며, 앞(Front)에서 노드가 제거된다. → **큐(Queue)**
3. 선형 리스트의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다. → **스택(Stack)**
4. 인터럽트 처리, 서브루틴 호출 작업 등에 응용된다. → **데크(Deque)**

<br />

### 32. 소프트웨어 재사용

> 소프트웨어를 재사용함으로써 얻을 수 있는 이점으로 가장 거리가 먼 것은?

<Callout type="error">
  소프트웨어를 재사용하면 **새로운 개발 방법론 도입이 어렵다.**
</Callout>

- 장점
  - 개발 시간과 비용 단축
  - 소프트웨어 품질 및 생산성 향상
  - 프로젝트 실패 위험 감소
  - 시스템 구축 방법에 대한 지식 공유
- 문제점
  - 재사용할 소프트웨어 선정 필요
  - 시스템에 공통적으로 사용되는 요소 발견 필요
  - 프로그램의 표준화 부족
  - 새로운 개발 방법론 도입이 어려움
  - 재사용을 위한 관리 및 지원 부족
  - 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어려움

<br />

### 33. 데이터 포맷

> 인터페이스 간의 통신을 위해 이용되는 데이터 포맷이 아닌 것은?

<Callout type="error">AJTML은 실존하지 않는 데이터 포맷이다.</Callout>

- JSON(JavaScript Object Notation): 경량 데이터 교환 형식으로, 웹 API 등에서 많이 사용됨
- XML(eXtensible Markup Language): 구조화된 데이터 표현을 위해 사용되는 마크업 언어
- YAML(YAML Ain’t Markup Language): 사람이 읽기 쉬운 데이터 직렬화 형식으로, 설정 파일이나 데이터 전송에 사용됨
- REST(Representational State Transfer): 웹과 같은 분산 하이퍼미디어 환경에서 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍쳐

<br />

### 34. 프로그램 설계도

> 프로그램 설계도의 하나인 NS Chart에 대한 설명으로 가장 거리가 먼 것은?

<Callout type="error">NS 차트는 GOTO나 화살표를 사용하지 않는다.</Callout>

- **NS 차트(Nassi-Shneiderman diagram)**
  - 논리 기술에 중점을 둔 도형을 이용한 표현 방법(Box Diagram, Chapin Chart)
  - 순차, 반복, 선택, 다중 선택 구조등 표현
  - GOTO나 화살표 사용하지 않음, 선택과 반복 구조를 시각화
  - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별
  - 박스 다이어그램이라고도 한다.

<br />

### 35. 스택 연산

> 순서가 A, B, C, D로 정해진 입력자료를 `push`, `push`, `pop`, `push`, `push`, `pop`, `pop`, `pop` 순서로 스택연산을 수행하는 경우 출력 결과는?

<Callout>
  입구 및 출구가 하나 `A B C D` 순으로 입력되었을 때 출력 순서는 `D C B A`
  순이다.
</Callout>

1. `push` → `A`
2. `push` → `A B`
3. `pop` → `A / B`
4. `push` → `A C / B`
5. `push` → `A C D / B`
6. `pop` → `A C / B D`
7. `pop` → `A / B D C`
8. `pop` → `/ B D C A`

<br />

### 36. 정렬

> 분할 정복(Divide and Conquer)에 기반한 알고리즘으로 피벗(pivot)을 사용하며 최악의 경우 `(n * (n-1) / 2)` 회의 비교를 수행해야 하는 정렬(Sort)은?

<Callout>해당 설명은 **퀵 정렬**에 대한 설명이다.</Callout>

- **선택 정렬**: 최소값을 찾아 앞쪽과 교환하는 정렬 (`O(n²)`)
- **버블 정렬**: 인접한 원소를 비교해 교환하는 단순한 정렬 (`O(n²)`)
- **퀵 정렬**: 피벗(`pivot`)을 기준으로 분할하며 정렬하는 효율적인 정렬 (평균 `O(n log n)`, 최악 `O(n²)` = `(n * (n-1) / 2)`)
  - 분할 정복(`Divide and Conquer`) 알고리즘 기반
- **힙 정렬**: 정렬 대상인 입력 레코드로 힙을 구성하고 가장 큰 키 값을 는 루트 노드를 제거하는 과정을 반복 (`O(n log n)`)
  - 완전 이진 트리(Complete binary tree)로 입력 자료의 레코드를 구성
- **합병 정렬**: 리스트를 1 이하인 상태까지 절반으로 나눠 재귀적으로 전체적인 리스트를 합병 (`O(n log n)`)
  - 분할 정복(`Divide and Conquer`) 알고리즘 기반
- **삽입 정렬**: 하나의 값을 추출하여 다음 앞쪽으로 비교하여 자리를 찾아가게끔 정렬 (`O(n²)`, 최선 `O(n)`)
  - 두 번째 자료부터 시작한다.
- **계수 정렬**: 각 숫자의 개수를 세어 위치를 정하는 정렬 (`O(n + k)`, `k` 는 값의 범위)
  - **버킷 정렬**은 계수 정렬을 일반화한 것이다.

<br />

### 37. 화이트박스 테스트

> 화이트 박스 검사 기법에 해당하는 것으로만 짝지어진 것은?

<Callout>
  화이트박스 테스트 기법으로 **데이터 흐름 검사, 루프 검사, 조건 검사, 기초 경로
  검사**가 있다. (기데조루)
</Callout>

1. 데이터 흐름 검사 → 화이트박스 테스트
2. 루프 검사 → 화이트박스 테스트
3. 동등 분할 검사 → 블랙박스 테스트
4. 경계값 분석 → 블랙박스 테스트
5. 원인 결과 그래프 기법 → 블랙박스 테스트
6. 오류예측 기법 → 블랙박스 테스트

<br />

### 38. 소프트웨어 품질

> 소프트웨어 품질 관련 국제 표준인 ISO/IEC 25000에 관한 설명으로 옳지 않은 것은?

<Callout>
  ISO/IE 2501n에서는 **품질 모델에 대한 설명**과 **적용 과정에서의 실질적인
  지침**을 포함한다.
</Callout>

- ISO/IEC 9126: 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성
- ISO/IEC 12119: 일반적인 제품 풀질 요구사항 및 테스트를 위한 국제 표준
- ISO/IEC 14598: 반복성, 재현성, 공정성, 객관성
- ISO/IEC 25000: 소프트웨어 품질 평가 통합 모델 표준 (앞의 세 가지 통합, 9126 + 12119 + 14598)
  - 2500n : 개요 및 품질관리
  - 2501n : 품질 모델
  - 2502n : 품질 측정
  - 2503n : 품질 요구
  - 2504n : 품질 평가
  - 2505n : 확장 분야
- ISO/IEC 15504: SPICE 모델 → 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준
- ISO/IEC 12207: CMM(능력 성숙도 모델) → SW 개발 업체들의 업무 능력 평가 기준을 세우기 위한 평가 모형

<br />

## 3과목

---

### 43. 정규형

> 어떤 릴레이션 R의 모든 조인 종속성의 만족이 R의 후보 키를 통해서만 만족될 때, 이 릴레이션 R이 해당하는 정규형은?

<Callout>
  후보키를 통하지 않는 조인 종속을 제거된 정규형은 **제5정규형**에 해당한다.
</Callout>

<Callout>
  2022년 4월 기출문제
  [정규형](/docs/engineer-information-processing/2022-04/#41-정규형) 문제 해설
  참고
</Callout>

- 1NF: 원자화
- 2NF: 부분 함수 종속 제거
- 3NF: 이행 함수 종속 제거
- BCNF: 결정자 함수 종속
- 4NF: 다치 종속성 제거
- 5NF: 조인 종속성 제거

<br />

### 44. E-R 모델

> E-R 모델에서 다중값 속성의 표기법은?

<Callout>다중값 속성은 **중복 원**을 통해 표현한다</Callout>

- **개체(Entity)**: 데이터베이스에서 **관리해야 할 대상**, **직사각형**으로 표현
  - **약한 개체**는 관계를 통해 식별되며, **이중 직사각형**으로 표현
- **속성(Attribute)**: 개체나 관계가 가지는 **특성**, **타원형**으로 표현
  - **다중값 속성**은 하나의 개체가 여러 값을 가질 수 있는 속성으로, **중복된 타원**으로 표현
  - **유도 속성**은 다른 속성에서 계산될 수 있는 속성으로, **점선 타원**으로 표현
- **관계(Relationship)**: **개체 간 연관성**을 나타내며, **마름모**로 표현
- **키(Key)**: 개체를 **고유하게 식별할 수 있는 속성**으로, 속성 이름을 **밑줄**로 표시

<br />

### 47. 릴레이션

> 다음 릴레이션의 Degree와 Cardinality는?

<Callout>
  릴레이션의 Degree는 열(차수)에 해당하고, Cardinality는 행(기수)에 해당한다.
  **(열차, 비행기)**
</Callout>

<br />

### 48. 뷰

> 뷰(View)에 대한 설명으로 틀린 것은?

<Callout type="error">뷰는 삽입, 갱신, 삭제 연산 시 제약 사항이 있다.</Callout>

1. 뷰 위에 또 다른 뷰를 정의할 수 있다.
2. DBA는 보안성 측면에서 뷰를 활용할 수 있다.
3. 사용자가 필요한 정보를 요구에 맞게 가공하여 뷰로 만들 수 있다.
4. ~~SQL을 사용하면 뷰에 대한 삽입, 갱신, 삭제 연산 시 제약 사항이 없다.~~

<br />

### 51. SQL

> CREATE TABLE문에 포함되지 않는 기능은?

<Callout type="error">
  속성 타입 변경은 `ALTER TABLE` 문을 통해 할 수 있다.
</Callout>

- `PRIMARY KEY`: 테이블의 기본 키를 정의 / 유일하게 테이블의 각 행을 식별
- `FOREIGN KEY`: 참조 대상을 테이블로 명시 / 외래 키를 정의 / 열과 참조된 테이블의 열 사이의 외래 키 관계를 적용하고 설정
- `UNIQUE`: 테이블 내에서 얻은 유일한 값을 갖도록 하는 속성
- `NOT NULL`: 해당 컬럼은 NULL값을 포함하지 않도록 하는 속성
- `CHECK`: 개발자가 정의하는 제약조건 / 참(TRUE)이어야 하는 조건을 지정
- `DEFAULT`: 해당 필드의 기본값을 설정

<br />

### 54. SQL

> 다음 SQL문에서 사용된 BETWEEN 연산의 의미와 동일한 것은?

```sql
SELECT *
FROM 성적
WHERE (점수 BETWEEN 90 AND 95)
        AND 학과 = "컴퓨터공학과";
```

<Callout>`BETWEEN` 구문은 **특정 값 이상, 특정 값 이하**로 연산된다. 답은 `점수 >= 90 AND 점수 <=95` 이다.</Callout>

<br />

### 55. 트랜잭션 상태

> 트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는?

<Callout>
  2022년 4월 기출문제 [트랜잭션
  상태](/docs/engineer-information-processing/2022-04#51-트랜잭션-상태) 해설
  참고
</Callout>

<Callout>
  해당 상태는 <strong>철회(Aborted)</strong>에 해당한다.
</Callout>

1. 철회(Aborted) → 비정상적으로 종료된 상태로, 이후 Rollback 연산이 수행된 상태
2. 부분 완료(Partially Committed) → 일부 작업을 완료하고 커밋을 기다리는 상태
3. 완료(Commit) → 정상적으로 완료되어, 영구적으로 데이터베이스에 반영된 상태
4. 실패(Failed) → 오류가 발생하여 실행이 중단된 상태

<br />

### 58. 분산 데이터베이스 시스템(DBS)

> 분산 데이터베이스 시스템(Distributed Database System)에 대한 설명으로 틀린 것은?

<Callout type="error">
  분산 데이터베이스 주요 구성 요소는 **전역, 분할, 할당, 지역 스키마**가 있다.
</Callout>

1. 분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러 개의 컴퓨터 사이트에 분산되어 있다.
2. 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다.
3. 데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용이 증가한다는 단점이 있다.
4. ~~분산 데이터베이스 시스템의 주요 구성 요소는 분산 처리기, P2P 시스템, 단일 데이터베이스 등이 있다.~~

<br />

## 4과목

---

### 61. IP 주소체계

> IP 주소체계와 관련한 설명으로 틀린 것은?

<Callout type="error">
  IPv6 헤더의 경우는 **40 octet**의 고정된 길이를 가진다.
</Callout>

1. ~~IPv6의 패킷 헤더는 32 octet의 고정된 길이를 가진다.~~
2. IPv6는 주소 자동설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있다.
3. IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원한다.
4. IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.

<br />

### 62. C언어 포인터

> 다음 C언어 프로그램이 실행되었을 때, 실행 결과는?

```c
#include <studio.h>
#include <stdlib.h>
int main (int argc, char *argv[]) {
    int arr[2][3]={1,2,3,4,5,6}
    int (*p)[3]=NULL;
    p=arr;
    printf("%d, ", *(p[0]+1) + *(p[1]+2));
    printf("%d", *(*(p+1)+0) + *(*(p+1)+1));
}
```

<Callout title="포인터 변수(`*`)">
  변수 메모리 주소를 저장하는 변수. 포인터라고 줄여서 부르기도 한다.
</Callout>

- `int arr[2][3]` → 각 요소 길이가 3인 2차원 배열을 생성한다.
  - `[[1, 2, 3], [4, 5, 6]]`
- `int (*p)[3]=NULL;` → `(*p)` 는 크기가 3인 정수 배열을 가리키는 포인터다.
- `p=arr;` → `p` 는 위 2차원 배열의 행(1차원 배열)을 가리키는 포인터가 된다.
- `printf("%d, ", *(p[0]+1) + *(p[1]+2));` 는 다음과 같이 처리된다.
  - `*(p[0]+1)` 에서 `p[0]` 는 `arr[0]` 에 해당하고 **포인터 산술 연산**에 의해 `p[0] + 1` 은 `p[0][1]` 가 된다.
  - `*` 는 포인터가 가리키는 값을 반환하기에 `2` 를 반환한다.
  - 동일한 연산 과정을 이후 연산에도 적용하면 `*(p[1]+2)` 은 `6` 을 반환하고 `2 + 6` 은 `8` 이다.
- `printf("%d", *(*(p+1)+0) + *(*(p+1)+1));` 는 다음과 같이 처리된다.
  - `*(*(p+1)+0)` 에서 `p+1` 은 `p` 가 가리키는 배열의 다음 행인 `p[1]` 이고 `*(p[1])` 은 역참조하여 `arr[1]` 배열을 가리킨다.
  - 이후 `*(p[1])+0` 은 `p[1][0]` 을 가리키고 이를 역참조하여 `*(*(p+1)+0)` 는 `4` 를 반환한다.
  - 동일한 연산 과정을 이후 연산에도 적용하면 `*(*(p+1)+1));` 는 `5` 를 반환해서 `4 + 5` 는 `9` 이다.

<br />

### 63. OSI 7계층

> OSI 7계층 중 데이터링크 계층에 해당되는 프로토콜이 아닌 것은?

<Callout type="error">HTTP는 **응용 계층**에 해당한다.</Callout>

1. ~~HTTP~~
2. HDLC
3. PPP
4. LLC

<Callout>
  [OSI 7계층
  정리](/docs/engineer-information-processing/written-summary#osi-7계층) 참고
</Callout>

<br />

### 65. IPv6

> IPv6에 대한 특성으로 틀린 것은?

<Callout type="error">IPv6는 **16비트씩 8부분의 16진수**로 표시한다.</Callout>

1. ~~표시방법은 8비트씩 4부분의 10진수로 표시한다.~~
2. 2128개의 주소를 표현할 수 있다.
3. 등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다.
4. 확장기능을 통해 보안기능을 제공한다.

<br />

### 67. TCP/IP 계층

> TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜은?

1. ~~ECP(Error Checking Protocol)~~
2. ARP(Address Resolution Protocol)
   - 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꿔주는 프로토콜
3. ICMP(Internet Control Message Protocol)
   - IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 프로토콜
4. PPP(Point-to-Point Protocol)
   - 점대점 데이터링크를 통해 3계층 프로토콜들을 캡슐화시켜 전송하는 프로토콜

<br />

### 69. 상호배제 기법

> 다음과 같은 형태로 임계 구역의 접근을 제어하는 상호배제 기법은?

```
P(S) : while S <= 0 do skip;
S := - 1;
V(S) : S := S + 1;
```

<Callout title="수식 이해하기">
  `S` 는 자원, `P(S)` 는 자원 할당, `V(S)` 자원 반환을 의미한다. 이 개념을 통해 수식을 해석해보면 다음과 같다.

<ul>
  <li>`P(S) : while S <= 0 do skip;` → 자원이 `0` 이하일 때 `skip`(반복문에서 대기) = 프로세스 대기</li>
  <li>`S := - 1;` → 자원이 `0` 보다 많으면(자원이 생기면), 프로세스에 자원 할당(`S:= S - 1`, 자원 감소)</li>
  <li>`V(S) : S := S + 1;` → 자원 반환을 통해 자원 증가</li>
</ul>

`P(S)` 연산을 통해 자원 유무를 판단하여 프로세스에 자원 할당 혹은 프로세스
대기를 실행하고, `V(S)` 연산을 통해 작업이 끝난 프로세스가 자원을 반환하도록
하는 것이라고 해석할 수 있다.

</Callout>

<Callout>
  **공유 자원에 대한 접근 제한**을 의미하므로
  <strong>Semaphore(세마포어)</strong>에 해당한다.
</Callout>

1. Dekker Algorithm → 상호배제 기법
   - 프로세스가 두 개일 때 상호배제를 보장하는 최초의 알고리즘으로, `flag`, `turn` 변수를 사용하여 조정
2. Lamport Algorithm → 상호배제 기법
   - 프로세스 n개의 상호배제 문제를 해결한 알고리즘으로, 프로세스에 부여한 고유 번호를 기준으로 우선순위를 정해 높은 프로세스가 먼저 임계구역에 진입하도록 구현
3. Peterson Algorithm → 상호배제 기법
   - 프로세스가 두 개일 때 상호배제를 보장하는 알고리즘으로, 데커의 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이가 있고 보다 간단
4. Semaphore → 동기화 기법
   - 공유된 자원의 데이터 혹은 임계영역 등에 따라 여러 프로세스 혹은 쓰레드가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)

<br />

### 71. 기억장치 관리

> 빈 기억공간의 크기가 20KB, 16KB, 8KB, 40KB 일 때 기억장치 배치 전략으로 “Best Fit"을 사용하여 17KB의 프로그램을 적재할 경우 내부단편화의 크기는 얼마인가?

<Callout title="기억장치 배치 전략">
  기억장치 배치 전략은 3가지가 있고 이는 아래와 같다.

  <ul>
    <li><strong>최초 적합(First Fit)</strong>: 가능한 영역 중에서 <strong>첫 번째 분할 영역</strong>에 배치시키는 방법</li>
    <li><strong>최적 적합(Best Fit)</strong>: 가능한 영역 중에서 <strong>단편화를 가장 작게 남기는 분할 영역</strong>에 배치하는 방법</li>
    <li><strong>최악 적합(Worst Fit)</strong>: 가능한 영역 중에서 <strong>단편화를 가장 많이 남기는 분할 영역</strong>에 배치하는 방법</li>
  </ul>
</Callout>

<Callout title="내부 단편화 계산">
  내부 단편화는 간단히 말해 **자투리 영역**을 의미하며 `빈 기억공간 크기 - 적재할 크기` 로 계산한다. 위 문제를 기준으로 빈 기억공간 별 내부
  단편화는 다음과 같다.

<ol>
  <li>**20KB** → 20KB - 17KB = **3KB**</li>
  <li>**16KB** → 적재 불가</li>
  <li>**8KB** → 적재 불가</li>
  <li>**40KB** → 40KB - 17KB = **23KB**</li>
</ol>

각 전략별 내부 단편화는 최초 적합의 경우 3KB, 최적 적합의 경우 3KB, 최악 적합의 경우 23KB에 해당한다. 문제의 정답은 **3KB**다.

</Callout>

<br />

### 74. 빌드 도구

> 개발 환경 구성을 위한 빌드(Build) 도구에 해당하지 않는 것은?

<Callout type="error">
  Kerberos는 빌드 도구가 아니라 **네트워크 인증 프로토콜**이다.
</Callout>

1. Ant → 자바 기반의 빌드 도구로, 프로젝트 빌드 및 배포를 자동화하는 데 사용됨.
2. Kerberos → 네트워크 인증 프로토콜로, 안전한 인증을 제공하기 위해 티켓 기반 인증 방식을 사용함.
3. Maven → 자바 프로젝트의 빌드, 의존성 관리, 배포를 자동화하는 빌드 도구.
4. Gradle → 자바 및 기타 언어의 빌드 및 의존성 관리를 지원하는 현대적인 빌드 도구.

<br />

### 75. 페이지 교체 알고리즘

> 3개의 페이지 프레임을 갖는 시스템에서 페이지 참조 순서가 1, 2, 1, 0, 4, 1, 3 일 경우 FIFO 알고리즘에 의한 페이지 교체의 경우 프레임의 최종 상태는?

<Callout title="단계별 과정">
  FIFO는 **가장 먼저 들어온 페이지를 가장 먼저 교체**하는 방식으로 동작한다. 해당 문제의 경우 아래와 같이 동작한다.

  <ol>
    <li>`1`: 프레임이 비어 있으므로 `1` 을 삽입 → `[1]`</li>
    <li>`2`: 프레임에 공간이 있으므로 `2` 를 삽입 → `[1, 2]`</li>
    <li>`1`: `1` 은 이미 프레임에 있으므로 그대로 유지 → `[1, 2]`</li>
    <li>`0`: 프레임에 공간이 있으므로 `0` 을 삽입 → `[1, 2, 0]`</li>
    <li>`4`: 프레임 공간이 없어 `1` 제거 및 `4` 추가 → `[2, 0, 4]`</li>
    <li>`1`: 프레임 공간이 없어 `2` 제거 및 `1` 추가 → `[0, 4, 1]`</li>
    <li>`3`: 프레임 공간이 없어 `0` 제거 및 `3` 추가 → `[4, 1, 3]`</li>
  </ol>
</Callout>

<Callout title="페이지 폴트(Page Fault)">
  프로세스가 참조하려는 **페이지가 메모리(프레임)에 없는 경우 발생**하며, 예제의
  경우 <strong>총 6번(1, 2, 0, 4, 1, 3)</strong>의 페이지 폴트가 발생한다.
</Callout>

<br />

### 76. C언어

> 다음 C언어 프로그램이 실행되었을 때, 실행 결과는?

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]) {
  char str1[20] = "KOREA";
  char str2[20] = "LOVE";
  char* p1=NULL;
  char* p2=NULL;
  p1=str1;
  p2=str2;
  str1[1]=p2[2];
  str2[3]=p1[4];
  strcat(str1, str2);
  printf("%c", *(p1+2));
  return 0;
}
```

<Callout title="실행 결과">
  위 문제의 실행 결과는 아래와 같다.

  <ul>
    <li>`str1[1]=p2[2];` → `"KOREA"` 의 `O` 가 `V` 로 변경 = `"KVREA"`</li>
    <li>`str2[3]=p1[4];` → `"LOVE"` 의 `E` 가 `A` 로 변경 = `"LOVA"`</li>
    <li>`strcat(str1, str2);` → `str1` 뒤에 `str2` 결합 `"KVREALOVA"`</li>
    <li>`*(p1+2)` → `p1` 이 가리키는 `"KVREALOVA"` 에서 `p[2]` 출력 = `"R"`</li>
  </ul>
</Callout>

<Callout type="warn" title="메모리 크기에 따른 결과">
  만약 `str1` 의 메모리 크기가 `9` 보다 부족한 경우,
  <strong>버퍼 오버플로우(Buffer Overflow)</strong>가 발생할 수 있다. 이 경우 프로그램
  충돌이 발생해 강제 종료되거나 예상치 못한 동작이 발생할 수 있다.
</Callout>

<br />

### 80. Shell

> UNIX 시스템의 쉘(shell)의 주요 기능에 대한 설명이 아닌 것은?

<Callout type="error">
  **프로세스와 메모리 관리**는 **커널**의 기능이다.
</Callout>

1. 사용자 명령을 해석하고 커널로 전달하는 기능을 제공한다.
2. 반복적인 명령 프로그램을 만드는 프로그래밍 기능을 제공한다.
3. ~~쉘 프로그램 실행을 위해 프로세스와 메모리를 관리한다.~~
4. 초기화 파일을 이용해 사용자 환경을 설정하는 기능을 제공한다.

<br />

## 5과목

---

### 81. 소프트웨어 생명주기

> 소프트웨어 생명주기 모델 중 나선형 모델(Spiral Model)과 관련한 설명으로 틀린 것은?

<Callout type="error">
  **점진적인 개발 과정이 반복**되므로 위험 분석 또한 **계획 수립 이후 추가적인
  위험 분석이 가능**하다.
</Callout>

1. 소프트웨어 개발 프로세스를 위험 관리(Risk Management) 측면에서 본 모델이다.
2. ~~위험 분석(Risk Analysis)은 반복적인 개발 진행 후 주기의 마지막 단계에서 최종적으로 한 번 수행해야 한다.~~
3. 시스템을 여러 부분으로 나누어 여러 번의 개발 주기를 거치면서 시스템이 완성된다.
4. 요구사항이나 아키텍처를 이해하기 어렵다거나 중심이 되는 기술에 문제가 있는 경우 적합한 모델이다.

<br />

### 82. 정보 시스템

> 정보시스템과 관련한 다음 설명에 해당하는 것은?
>
> - 각 시스템 간에 공유 디스크를 중심으로 클러스터링으로 엮여 다수의 시스템을 동시에 연결할 수 있다.
> - 조직, 기업의 기간 업무 서버 등의 안정성을 높이기 위해 사용될 수 있다.
> - 여러 가지 방식으로 구현되며 2개의 서버를 연결하는 것으로 2개의 시스템이 각각 업무를 수행하도록 구현하는 방식이 널리 사용된다.

1. 고가용성 솔루션(HACMP)
   - AIX를 기반으로 한 IBM의 High Availability Solution
   - Resource의 중복 또는 공유를 통해 Application의 보호를 가능하게 해줌
   - 같은 Data를 공유하거나 동시에 access하는 node들에서 여러 개의 application을 실행하게 해줌
   - 두 대 이상의 시스템을 하나의 Cluster로 묶어 Cluster내의 한 시스템에서 장애가 발생할 경우 다른 시스템이 장애가 발생한 시스템의 자원을 인수할 수 있도록 하여 서비스의 중단을 최소화 할 수 있도록 도와주는 솔루션
2. 점대점 연결 방식(Point-to-Point Mode)
   - 네트워크에 있어 물리적으로는 중개 장치를 통과하지 않고 한 지점에서 다른 지점으로 직접 가는 채널
   - 두 스테이션 간을 별도의 회선을 사용하여 1대1로 연결.
   - 전용 회선이나 공중 전화 회선을 이용.
   - 회선 구성이 간단하고 대용량 전송에 유리.
   - 별도의 회선과 포트에 따른 높은 설치비용
3. 스턱스넷(Stuxnet)
   - 2010년 6월에 발견된 웜 바이러스
   - 윈도우를 통해 감염, 지맨스산업의 SW 및 장비를 공격
4. 루팅(Rooting)
   - 모바일 기기에서 구동되는 안드로이드 운영체제상에서 최상위 권한 (루트 권한)을 얻음으로 해당 기기의 생산자 또는 판매자 측에서 걸어 놓은 제약을 해제하는 행위

<br />

### 83. 네트워크 공격

> 위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려보내, 스위치 MAC 주소 테이블의 저장 기능을 혼란시켜 더미 허브(Dummy Hub)처럼 작동하게 하는 공격은?

1. Parsing
   - 하나의 프로그램을 런타임 환경(예를 들면, 브라우저 내 자바스크립트 엔진)이 실제로 실행할 수 있는 내부 포맷으로 분석하고 변환하는 것을 의미함
2. LAN Tapping
   - LAN 신호를 가로채거나 복사하여 네트워크 트래픽을 모니터링하거나 분석하는 행위
3. Switch Jamming
   - 스위치의 기능이 방해 받아 정상 동작을 하지 못해 스위치가 더미 허브처럼 작동 하게 되는 것. Switch + Jamming(방해)
4. FTP Flooding
   - TCP의 3 Way Handshake 취약점을 이용한 DoS 공격으로 다량의 SYN패킷을 보내 백로그 큐를 가득 채우는 공격
   - 통상적으로 위의 공격법을 TCP SYN Flooding 이라고 칭하는 경우가 많음
   - FTP 프로토콜을 사용한 서버에 다량의 SYN 패킷을 보내 마비시키는것을 FTP Flooding이라고 볼 수 있음.

<br />

### 86. 소프트웨어 생명주기

> 소프트웨어 생명주기 모델 중 V 모델과 관련한 설명으로 틀린 것은?

<Callout title="V 모델(V-Model)">
  소프트웨어 개발 프로세스로 **폭포수 모델의 확장된 형태 중 하나**로 볼 수 있다.
  아래 방향으로 선형적으로 내려가면서 진행되는 폭포수 모델과 달리, 이 프로세스는
  **코딩 단계에서 위쪽으로 꺾여서 알파벳 V자 모양으로 진행**된다.
</Callout>

<Callout type="error">
  요구 분석 및 설계 단계를 거치며, 구현 후 **단위 > 통합 > 시스템 > 인수
  테스트**로 각 개발 단계를 검증한다.
</Callout>

1. ~~요구 분석 및 설계 단계를 거치지 않으며 항상 통합 테스트를 중심으로 V 형태를 이룬다.~~
2. Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.
3. 개발 작업과 검증 작업 사이의 관계를 명확히 드러내 놓은 폭포수 모델의 변형이라고 볼 수 있다.
4. 폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.

<br />

### 87. 블루투스 공격

> 블루투스(Bluetooth) 공격과 해당 공격에 대한 설명이 올바르게 연결된 것은?

1. 블루버그(BlueBug) - 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람
   - 블루스나프에 해당
2. 블루스나프(BlueSnarf) - 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것
   - 블루재킹에 해당
3. 블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미
4. 블루재킹(BlueJacking) - 블루투스 장비사이의 취약한 연결 관리를 악용한 공격
   - 블루버그에 해당

<br />

### DoS(Denial of Service)

> DoS(Denial of Service) 공격과 관련한 내용으로 틀린 것은?

<Callout type="error">
  Smurf 공격은 멀티캐스트가 아닌 **브로드캐스트**를 활용한다.
</Callout>

1. Ping of Death 공격은 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.
2. ~~Smurf 공격은 멀티캐스트(Multicast)를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.~~
3. SYN Flooding은 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.
4. Land 공격은 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다.

<br />

### 91. 간트 차트

> 간트 차트(Gantt Chart)에 대한 설명으로 틀린 것은?

<Callout type="error">
  수평 막대의 길이는 각 **작업에 필요한 기간**에 해당한다.
</Callout>

1. 프로젝트를 이루는 소작업 별로 언제 시작되고 언제 끝나야 하는지를 한 눈에 볼 수 있도록 도와준다.
2. 자원 배치 계획에 유용하게 사용된다.
3. CPM 네트워크로부터 만드는 것이 가능하다.
4. ~~수평 막대의 길이는 각 작업(Task)에 필요한 인원수를 나타낸다.~~

<br />

### 93. Secure 코딩

> Secure 코딩에서 입력 데이터의 보안 약점과 관련한 설명으로 틀린 것은?

<Callout title="시큐어 코딩(Secure Coding)">
  해킹 등 사이버 공격의 원인인 **보안취약점을 제거**해 안전한 소프트웨어를
  개발하는 SW 개발 기법을 말한다.
</Callout>

<Callout type="error">
  자원 삽입은 **자원을 조작할 수 있는 문자열을 삽입**하여 시스템이 보호하는
  자원에 임의로 접근 할 수 있는 취약점이다.
</Callout>

1. SQL 삽입 : 사용자의 입력 값 등 외부 입력 값이 SQL 쿼리에 삽입되어 공격
2. 크로스사이트 스크립트 : 검증되지 않은 외부 입력 값에 의해 브라우저에서 악의적인 코드가 실행
3. 운영체제 명령어 삽입 : 운영체제 명령어 파라미터 입력 값이 적절한 사전검증을 거치지 않고 사용되어 공격자가 운영체제 명령어를 조작
4. ~~자원 삽입 : 사용자가 내부 입력 값을 통해 시스템 내에 사용이 불가능한 자원을 지속적으로 입력함으로써 시스템에 과부하 발생~~

<br />

### 94. Windows 파일 시스템

> Windows 파일 시스템인 FAT와 비교했을 때의 NTFS의 특징이 아닌 것은?

<Callout title="FAT">
  DOS때부터 사용되던 윈도우의 파일 시스템으로, 저용량에 적합하며 호환성이 좋다.
  저장가능한 파일의 최대크기가 4GB이다.
</Callout>

<Callout title="NTFS">
  FAT 시스템을 대체하기 위해 개발된 윈도우 파일 시스템으로, 사용자마다 다른 보안
  적용 가능하기에 보안이 FAT 보다 좋으며, 대용량 저장 가능 및 안정성이 뛰어나다.
</Callout>

1. ~~보안에 취약~~
2. 대용량 볼륨에 효율적
3. 자동 압축 및 안정성
4. 저용량 볼륨에서의 속도 저하

<br />

### 95. 암호화 알고리즘

> DES는 몇 비트의 암호화 알고리즘인가?

<Callout>
  DES는 블록 크기는 **64비트** 이고, 키 길이가 **56비트** 이다. DES의 키는
  7비트마다 오류 검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는
  56비트이다.
</Callout>

1. 8
2. 24
3. 64
4. 132

<br />

### 96. 리눅스

> 리눅스에서 생성된 파일 권한이 644일 경우 umask 값은?

<Callout>
  umask는 UNIX에서 파일이나 디렉터리의 초기 권한을 설정할 때 사용하는 값으로
  파일의 경우 666에서 umask를 뺀 값을, 디렉터리일 경우 777에서 umask를 뺀 값을
  초기 접근 권한으로 갖는다. 파일 권한이 644면 umask 값은 022에 해당한다.
</Callout>

1. 022
2. 666
3. 777
4. 755

<br />

### 97. 로그 파일

> 다음 내용이 설명하는 로그 파일은?
>
> - 리눅스 시스템에서 사용자의 성공한 로그인/로그아웃 기록
> - 시스템의 종료/시작 시간 기록

<Callout title="`wtmp`">
  성공한 로그인/로그아웃 정보를 담고 있는 로그 파일이다. `var/log/wtmp` 에
  위치하며 `last` 명령어를 사용한다.
</Callout>

<br />

### 98. 소프트웨어 비용 산정

> 상향식 비용 산정 기법 중 LOC(원시 코드 라인 수) 기법에서 예측치를 구하기 위해 사용하는 항목이 아닌 것은?

<Callout>
  LOC 예측치를 구하기 위해서는 **낙관치, 비관치, 기대치**가 필요하다. 예측치는
  `(비관치 + 4 x 기대치 + 낙관치) / 6` 로 구할 수 있다.
</Callout>

1. 낙관치
2. 기대치
3. 비관치
4. ~~모형치~~

<br />

### 99. DPI

> OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술은?

<Callout title="DPI(Deep Packet Inspection)">
  네트워크에서 전송되는 **패킷의 헤더와 페이로드 내 정보를 분석하는 컨텐츠 내용
  분석 기술**이며, 네트워크 보안, 관리, 컨텐츠 관리 등이 목적이다.
</Callout>

1. PLCP(~~Packet Level Control Processor~~ Physical Layer Convergence Procedure: 물리계층 수렴 처리)
   - 논리적인 802.11 MAC 부계층과 물리적인 특성을 연결하는 역할
   - 802.11 MAC 부계층이 물리적 특성에 관계없이 동작하도록 함
2. Traffic Distributor
   - 네트워크 통신 간에 트래픽을 분배해주는 솔루션
3. Packet Tree
4. DPI(Deep Packet Inspection)

<br />

### 100. 소프트웨어 개발 방법론

> 소프트웨어 개발 방법론의 테일러링(Tailoring)과 관련한 설명으로 틀린 것은?

<Callout title="테일러링(Tailoring)">
  프로젝트 상황 특성에 맞게 정의된 소프트웨어 개발 방법론 절차, 사용 기법 등을
  수정 및 보완하는 작업이다.
</Callout>

1. ~~프로젝트 수행 시 예상되는 변화를 배제하고 신속히 진행하여야 한다.~~
2. 프로젝트에 최적화된 개발 방법론을 적용하기 위해 절차, 산출물 등을 적절히 변경하는 활동이다.
3. 관리 측면에서의 목적 중 하나는 최단기간에 안정적인 프로젝트 진행을 위한 사전 위험을 식별하고 제거하는 것이다.
4. 기술적 측면에서의 목적 중 하나는 프로젝트에 최적화된 기술 요소를 도입하여 프로젝트 특성에 맞는 최적의 기법과 도구를 사용하는 것이다.
