---
title: "2022년 4월"
description: "2022년 4월 정보처리기사 기출문제 풀이 후 작성한 오답노트입니다."
icon: NotebookPen
---

import { Accordion, Accordions } from "fumadocs-ui/components/accordion";

## 요약

---

- 이론 학습 전 연습용으로 풀어본 기출 문제
- 3, 4과목이 많이 약한 것으로 파악되며 이론 학습 시 해당 과목을 집중적으로 학습하면 좋을 듯
- 67번 이후의 오답 노트는 캡쳐를 유실하여 추후 다시 풀고 추가하기

<br />

## 2과목

---

### 22. 이진 탐색 동작 방식

<Callout>
  `mid = (low + high) / 2` 를 통해 중간 인덱스를 찾고 이를 반복한다.
</Callout>

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
```

- 해당 문제의 경우 다음 순서로 탐색이 진행되며 총 **3번**의 탐색을 통해 찾을 수 있다.
  1. `low = 0`, `high = 14`, `mid = (0 + 14) // 2 = 7` → `arr[7] = 8` (오른쪽 탐색)
  2. `low = 8`, `high = 14`, `mid = (8 + 14) // 2 = 11` → `arr[11] = 12` (오른쪽 탐색)
  3. `low = 12`, `high = 14`, `mid = (12 + 14) // 2 = 13` → `arr[13] = 14` 🎯

<br />

### 28. 위험 모니터링

<Callout>
  위험 모니터링이란 **위험 요소 징후들에 대하여 계속적으로 인지하는 것**이다.
</Callout>

<br />

### 31. 알고리즘

<Callout type="error">
  검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 하는 것은 **이진
  검색**이다.
</Callout>

<Callout type="info">
  선형 검색은 **처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는
  검색**이다.
</Callout>

1. 주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다.
2. 검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다.
3. 정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다.
4. ~~선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.~~

<br />

### 32. 버블 정렬

<Callout title="버블 정렬">
  버블 정렬은 **첫 위치부터 시작해서 오른쪽 값과 비교하는 방식**으로 진행되며,
  PASS 1은 **첫 버블 정렬이 끝난 상태**다.
</Callout>

```
9, 6, 7, 3, 5
```

- PASS 1의 결과 도출 과정은 아래와 같다.
  1. `9 > 6` → 스왑 → `6, 9, 7, 3, 5`
  2. `9 > 7` → 스왑 → `6, 7, 9, 3, 5`
  3. `9 > 3` → 스왑 → `6, 7, 3, 9, 5`
  4. `9 > 5` → 스왑 → `6, 7, 3, 5, 9`

<br />

### 33. 인스펙션(Inspection) 과정

<Callout title="진행 과정">
  **계획 → 사전 교육 → 준비 → 인스펙션 회의 → 수정 → 후속 조치** 순으로
  진행되며, 수정이 발생하면 계획으로 돌아간다.
</Callout>

<br />

### 35. 단위 테스트(Unit Test)

<Callout type="error">
  필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을
  하는 가상의 모듈은 <strong>테스트 드라이버(test driver)</strong>다.
</Callout>

<Callout type="info">
  테스트 스텁(test stub)은 **인자를 통해 받은 값을 가지고 수행한 후 그 결과를
  테스트할 모듈에 넘겨주는 역할**을 한다.
</Callout>

1. 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
2. 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
3. ~~필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.~~
4. 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.

<br />

### 37. 트리(Tree) 구조의 순회 방식

<Callout type="info">
  후위 순회는 `왼쪽 → 오른쪽 → 루트` 순서로 순회한다.
</Callout>

```
        a
       / \
      b   c
     /   / \
    d   e   f
       / \
      g   h
```

| 순회 방식 | 진행 방향            | 결과 순서                     |
| --------- | -------------------- | ----------------------------- |
| 전위 순회 | 루트 → 왼쪽 → 오른쪽 | a → b → d → c → e → g → h → f |
| 중위 순회 | 왼쪽 → 루트 → 오른쪽 | d → b → a → g → e → h → c → f |
| 후위 순회 | 왼쪽 → 오른쪽 → 루트 | d → b → g → h → e → f → c → a |
| 레벨 순회 | 위 → 아래, 좌 → 우   | a → b → c → d → e → f → g → h |

<br />

## 3과목

---

### 40. 단위 테스트 도구

<Callout type="error">IgpUnit은 존재하지 않는 유닛입니다.</Callout>

<Callout type="info">
  **CppUnit**은 C++ 단위 테스트 도구, **JUnit**은 Java 단위 테스트 도구,
  **HttpUnit**은 브라우저 없이 웹사이트 테스트를 수행하기 위한 테스트
  프레임워크다.
</Callout>

1. CppUnit
2. JUnit
3. HttpUnit
4. ~~IgpUnit~~

<br />

### 41. 정규형

<Callout title="조건에 맞는 정규형 찾기">
  정규형의 경우 **이전 단계를 충족**해야 하기 때문에, **가장 높은 단계**를
  선택해야 한다.
</Callout>

- **1NF**: 테이블 내의 속성값은 원자값을 가지고 있어야 한다.
- **2NF**: 부분 함수 종속을 제거한다. (완전 함수 종속 관계).
- **3NF**: 이행 함수 종속을 제거한다.
- **BCNF**: 결정자가 후보키인 정규형이며, 함수 종속을 제거한다.
- **4NF**: 다치 종속을 제거한다.
- **5NF**: 조인 종속을 제거한다.

<br />

### 42. 트랜잭션의 특성

<Callout title="트랜잭션이란">
  트랜잭션(Transaction)이란 **데이터베이스의 상태를 변화시키기 해서 수행하는
  작업의 단위**다.
</Callout>

- **원자성(Atomicity)**: 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함
- **일관성(Consistency)**: 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함
- **격리성(Isolation, 고립성)**: 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
- **영속성(Durability, 지속성)**: 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨

<br />

### 45. 데이터베이스 인덱스

<Callout title="인덱스(Index)란">
  데이터베이스에 **저장된 자료를 빠르게 조회하기 위하여 별도로 구성한 순서
  데이터**를 말하며, 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유한다.
  또한, 대부분의 데이터베이스에서 **테이블을 삭제하면 인덱스도 같이 삭제**된다.
</Callout>

<Callout type="error">
  인덱스 생성 명령어는 `CREATE`, 삭제 명령어는 `DROP` 이다.
</Callout>

1. 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.
2. 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다.
3. ~~인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.~~
4. 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.

<br />

### 47. SQL 명령어

<Callout title="SQL이란">
  <strong>SQL(Structured Query Language)</strong>은 관계형 데이터베이스에서
  데이터를 정의, 조작, 검색, 수정, 삭제하고, 트랜잭션을 관리하는 표준 프로그래밍
  언어다.
</Callout>

<Accordions type="multiple">
  <Accordion title="DDL(Data Definition Language)">
    데이터베이스 **구조 정의**에 사용되며, **테이블이나 컬럼 등을 생성, 수정, 삭제**한다.

    - `CREATE`: 새로운 테이블 생성
    - `ALTER`: 기존 테이블 구조 생성
    - `DROP`: 기존 테이블 삭제
    - `TRUNCATE`: 기존 테이블 초기화
    - `RENAME`: 기존 테이블 이름 변경

  </Accordion>
  <Accordion title="DML(Data Manipulation Language)">
    데이터베이스에 저장된 **데이터를 조회, 삽입, 수정, 삭제**하는데 사용된다.

    - `SELECT`: 데이터 조회
    - `INSERT`: 새로운 데이터 삽입
    - `UPDATE`: 기존 데이터 수정
    - `DELETE`: 기존 데이터 삭제

  </Accordion>
  <Accordion title="DCL(Data Control Language)">
    데이터베이스에 대한 **접근 권한을 제어**하는데 사용된다.

    - `GRANT`: 사용자에게 권한 부여
    - `REVOKE`: 사용자에게 부여된 권한 회수

  </Accordion>
  <Accordion title="TCL(Transaction Control Language)">
    트랜잭션의 **처리와 제어를 위한 명령어**로, 데이터의 일관성과 무결성을 보장한다.

    - `COMMIT`: 트랜잭션의 작업 내용을 확정
    - `ROLLBACK`: 트랜잭션의 작업 내용을 취소
    - `SAVEPOINT`: 트랜잭션 내 특정 지점을 저장하여 ROLLBACK 시 기준으로 사용

  </Accordion>

</Accordions>

<br />

### 48. 데이터 사전(Data Dictionary)

<Callout type="error">
  데이터 사전은 데이터베이스 시스템의 관리자 또는
  <strong>DBA(Database Administrator)</strong>에 의해 관리되며, **일반 사용자가 이를
  수정하는 것은 보통 권한상 제한**된다.
</Callout>

1. 시스템 카탈로그 또는 시스템 데이터베이스라고도 한다.
2. ~~데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다.~~
3. 데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다.
4. 데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다.

<br />

### 49. 데이터베이스 릴레이션(Relation)

<Callout title="릴레이션(Relation)과 튜플(Tuple)">
  **릴레이션**은 데이터를 표 형태로 표현한 **2차원 테이블**이며, **튜플**은
  릴레이션의 각 **행**으로, 릴레이션에서 정의된 속성 값들을 가지는 하나의 데이터
  레코드입니다. 또한, **튜플의 유일성, 튜플의 무순서성, 속성의 원자성, 속성의
  무순서성**의 특징을 가진다.

</Callout>

<Callout type="error">
  하나의 릴레이션에 포함된 **튜플은 순서가 없으며**, 순서에 의미가 없다.
</Callout>

1. 모든 튜플은 서로 다른 값을 가지고 있다.
2. ~~하나의 릴레이션에서 튜플은 특정한 순서를 가진다.~~
3. 각 속성은 릴레이션 내에서 유일한 이름을 가진다.
4. 모든 속성 값은 원자 값(atomic value)을 가진다.

<br />

### 50. 데이터베이스 뷰(View)

<Callout title="데이터베이스 뷰란">
  **데이터베이스 뷰**는 **하나 이상의 테이블에서 데이터를 추출**하여 **가상
  테이블 형태**로 제공하며, 실제 데이터는 저장하지 않고 **쿼리 결과를 동적으로
  보여주는 논리적 구조**다.
</Callout>

<Callout type="error">뷰는 **논리적으로만 존재**한다.</Callout>

1. 뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.
2. 뷰는 일종의 가상 테이블이며, update에는 제약이 따른다.
3. 뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다.
4. ~~뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.~~

<br />

### 51. 트랜잭션 상태

- <strong>활성(Active)</strong>: 트랜잭션이 **실행 중인 상태**로, 아직
  커밋되거나 롤백되지 않은 상태다.
- <strong>부분 커밋(Partial Commit)</strong>: 트랜잭션이 **일부 작업을
  완료**하고 **커밋을 기다리고 있는 상태**다.
- <strong>커밋(Committed)</strong>: 트랜잭션이 **정상적으로 완료**되어, 변경
  사항이 **영구적으로 데이터베이스에 반영된 상태**다.
- <strong>롤백(Rolled Back)</strong>: 트랜잭션이 **중단되거나 오류가 발생**하여,
  **변경 사항을 모두 취소**하고 데이터베이스 상태를 **트랜잭션 시작 이전으로
  되돌린 상태**다.
- <strong>실패(Failed)</strong> : 트랜잭션이 작업 수행 도중 **오류가 발생하여 중단된
  상태**이다.
- <strong>철회(Aborted)</strong>: 트랜잭션이 **비정상적으로 종료**되어, 이후
  **Rollback 연산이 수행된 상태**.

<br />

### 52. SQL 명령 구분짓기

<Callout>
  47번 문제의 [SQL
  명령어](/docs/engineer-information-processing/2022-04/#47-sql-명령어) 참고
</Callout>

<br />

### 53. 테이블 키의 종류

<Callout>
  키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은
  <strong>후보키(Candidate key)</strong>다.
</Callout>

- <strong>슈퍼키(Super Key)</strong>: 유일성을 만족하는 키.
- <strong>복합키(Composite Key)</strong>: 2개 이상의 속성(attribute)를 사용한
  키.
- <strong>후보키(Candidate key)</strong>: 유일성과 최소성을 만족하는 키.
  기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다.
- <strong>기본키(Primary key)</strong>: 후보 키에서 선택된 키. NULL값이 들어갈
  수 없으며, 기본키로 선택된 속성(Attribute)은 동일한 값이 들어갈 수가 없다.
- <strong>대체키(Surrogate key)</strong>: 후보 키 중에 기본 키로 선택되지 않은
  키.
- <strong>외래키(Foreign Key)</strong>: 어떤 테이블(Relation) 간의 기본
  키(Primary key)를 참조하는 속성이다. 테이블(Relation)들 간의 관계를 나타내기
  위해서 사용된다.

<br />

### 55. 테이블의 기본키(Primary Key)

<Callout>
  53번 문제의 [테이블 키의
  종류](/docs/engineer-information-processing/2022-04/#53-테이블-키의-종류) 참고
</Callout>

<Callout type="error">
  기본키는 검색할 때 **반드시 필요하지는 않지만**, **기본키로 조회하면 유일한
  튜플을 조회**할 수 있다.
</Callout>

1. NOT NULL로 널 값을 가지지 않는다.
2. 릴레이션에서 튜플을 구별할 수 있다.
3. 외래키로 참조될 수 있다.
4. ~~검색할 때 반드시 필요하다.~~

<br />

### 56. 데이터 모델 구성요소

<Callout>
  DBMS에서의 실제 표현과 동작을 정의한 것으로, **데이터 모델이 어떻게 동작하고
  표현되는지를 정의하는 핵심 요소**다.
</Callout>

| 항목                   | 설명                                                                                                       |
| ---------------------- | ---------------------------------------------------------------------------------------------------------- |
| 데이터 구조(Structure) | 데이터 구조 및 정적 성질을 표현한다. (테이블, 열, 행 구조 등)                                              |
| 연산(Operation)        | 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값을 처리하는 작업이다. (조회, 삽입, 삭제 등) |
| 제약 조건(Constraint)  | 데이터의 논리적 제한 명시 및 조작의 규칙이다. (무결성 유지, 중복 방지 등)                                  |

<br />

### 57. SQL 구문 분석

```
[조건]
이름이 '정도일'인 팀원이 소속된 팀코드를 이용하여 해당 팀에 소속된 팀원들의 이름을 출력하는 SQL문 작성
```

```
[SQL문]
SELECT  이름
FROM    직원
WHERE   팀코드 = (    );
```

- 하위 질의문은 하위 질의를 먼저 처리하고 검색된 결과는 상위 질의에 적용되어 검색된다.
- 직원 테이블에서 “정도일” 팀원의 팀 코드를 검색하여 상위 질의에 반환한다.

```
[정답]
SELECT 팀코드 FROM 직원
WHERE 이름 = '정도일'
```

<br />

### 59. 관계 데이터 모델

<Callout title="관계 데이터 모델(Relational Data Model)이란">
  데이터를 <strong>행(Row)과 열(Column)</strong>로 구성된 **2차원
  테이블(릴레이션) 형태**로 표현하는 데이터 모델이다.
</Callout>

- <strong>Degree(차수)</strong>: 속성의 수
- <strong>Cardinality(기수)</strong>: 튜플의 수

<br />

### 60. SQL 구문

- **권한 부여**: `GRANT CREATE TABLE FROM [TARGET];`
- **권한 취소**: `REVOKE CREATE TABLE FROM [TARGET];`

<br />

## 4과목

---

### 63. C언어

```c
#include <stdio.h>

struct st {
    int a;
    int c[10];
};

int main(int argc, char *argv[]) {
    int i = 0;
    struct st ob1;
    struct st ob2;
    ob1.a = 0;
    ob2.a = 0;

    for(i = 0; i < 10; i++) {
        ob1.c[i] = i;
        ob2.c[i] = ob1.c[i] + i;
    }

    for(i = 0; i < 10; i = i + 2) {
        ob1.a = ob1.a + ob1.c[i];
        ob2.a = ob2.a + ob2.c[i];
    }

    printf("%d", ob1.a + ob2.a);
    return 0;
}
```

- 정답은 `ob1.a + ob2.a = 20 + 40 = 60`
- 짝수 인덱스만 더하는 부분을 놓치고 실수한 문제

<br />

### 64. IP 프로토콜

<Callout title="IP 프로토콜">
  데이터를 송신지에서 수신지까지 전달하기 위해 **IP 주소를 기반으로 경로를
  지정**하고 **패킷을 전송**하는 **네트워크 계층 프로토콜**이다.
</Callout>

<Callout type="error">
  Packet Length는 IP 헤더와 데이터를 **포함한** IP 패킷 전체의 길이를 바이트
  단위로 나타내는 필드이다.
</Callout>

1. Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
2. ~~Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 2³²-1 비트이다.~~
3. Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
4. Version Number는 IP 프로토콜의 버전번호를 나타낸다.

<br />

### 65. Python

```python
x = 20

if x == 10:
    print('10')

(      ) x == 20:
    print('20')

else:
    print('other')
```

- 파이썬 조건문 키워드는 `if`, `elif`, `else` 다.
- 정답은 `elif`

<br />

### 66. RIP

<Callout type="error">
  라우팅 프로토콜을 IGP와 EGP로 분류했을 때 RIP는 OSPF와 함께 **IGP**에
  해당한다.
</Callout>

<Callout title="RIP(Routing Information Protocol)">
  **Bellman-Ford 알고리즘**을 사용하는
  <strong>거리 벡터(distance-vector) 기반</strong>의 라우팅 프로토콜로, 네트워크
  내에서 최적의 경로를 결정하기 위해 <strong>홉 수(hop count)</strong>를 주요 지표로
  사용한다.
</Callout>

<Callout title="IGP(Interior Gateway Protocol)">
  내부 게이트 프로토콜로 **학내망 내부에서 라우팅 하는 것**을 의미한다. 즉,
  하나의 AS 내에서 라우팅에 사용되는 프로토콜이다.
</Callout>

<Callout title="EGP(Exterior Gateway Protocol)">
  외부 게이트 프로토콜로 **다른 학내망의 라우팅에 사용**된다. 즉, AS 간의
  라우팅에 사용되는 프로토콜이다.
</Callout>

1. 경로 선택 메트릭은 홉 카운트(hop count)이다.
2. ~~라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.~~
3. 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다.
4. 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신한다.

<br />

### 67. 프로세스 스케줄링

<Callout title="스케줄링">
  프로세스가 생성되어 실행될 때 **필요한 시스템의 여러 자원을 해당 프로세스에
  할당하는 작업**을 의미한다.
</Callout>

- **선점 스케줄링**: 할당된 CPU를 우선순위가 높은 프로세스가 빼앗아 사용할 수 있는 기법
  - <strong>라운드 로빈(Round Robin)</strong>: 프로세스마다 같은 크기의 CPU
    시간을 할당하고, 시간 내 처리 못하면 큐 리스트 마지막으로 이동
  - <strong>SRT(Shortest Remaining Time First)</strong>: 가장 짧은 시간이
    소요되는 프로세스를 먼저 수행
  - <strong>다단계 큐(Multi Level Queue)</strong>: 작업들을 여러 종류 그룹으로
    분할하고, 여러 개의 큐를 이용하여 상위 단계 작업이 선점
  - <strong>다단계 피드백 큐(Multi Level Feedback Queue)</strong>: 입출력 위주와
    CPU 위주인 프로세스 특성에 따라 큐마다 서로 다른 CPU 시간 할당량 부여.
    FCFS와 라운드 로빈 기법 혼합
- **비선점 스케줄링**: 할당된 CPU를 강제로 빼앗을 수 없는 기법
  - <strong>우선순위(Priority)</strong>: 각 프로세스 별로 우선순위가 주어지고,
    우선순위에 따라 배정
  - <strong>기한부(Deadline)</strong>: 작업들이 명시된 기간이나 기한 내에
    완료하도록 계획
  - **FCFS(First Come First Serve)/FIFO**: 먼저 요청한 프로세스가 먼저 CPU를 배정
  - <strong>SJF(Shortest Job First)</strong>: 프로세스 도착 시점에서 가장 짧은
    프로세스가 종료까지 CPU 선점
  - <strong>HRN(Highest Response Ratio Next)</strong>: 대기 중인 프로세스 중
    Response Ratio(`(대기 시간 + 서비스 시간) / 서비스 시간`)이 가장 높은 것을
    선택
