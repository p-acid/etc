---
title: "2020년 실기 기출문제"
description: "2020년 실기 기출문제 풀이 모음"
icon: NotebookPen
---

## 1회차

### XML

> 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 다목적 마크업 언어이다.

### JSON

> 속성-값 쌍(attribute-value pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷이다. AJAX에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷이다. 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있다.

### 릴리즈 노트 헤더

> 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등의 기존정보가 포함된다.

### 살충제 패러독스

> 동일한 살충제를 반복적으로 사용하면 벌레에게 내성이 생기는 것처럼, 동일한 테스트 기법이나 전략을 적용하면 장애가 발견되지 않는 것

### 데이터 마이닝

> 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 분석하여 가치있는 정보를 추출하는 과정이다.

### 프로토콜 구성 요소

> - **구문(Syntax)**: 프로토콜에서 사용하는 **메시지의 형식과 구조**를 정의합니다. 메시지의 길이, 형식, 필드 구성 등이 포함됩니다.
> - **의미(Semantics)**: 프로토콜에서 사용하는 **메시지의 의미와 해석**을 정의합니다. 메시지의 내용과 처리 방법 등을 포함합니다.
> - **타이밍(Timing)**: 프로토콜에서 사용하는 **메시지의 전송 시점과 순서**를 정의합니다. 메시지의 전송 시간, 대기 시간, 순서 등이 포함됩니다.

### 해시 함수 MD5

> 128비트 암호화 해시 함수로 RFC 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 1991년에 로널드 라이베스트(Ronald Rivest)가 예전에 쓰이던 MD4를 대체하기 위해 고안하였다.

### HRN 우선순위 계산식

> **우선순위 = (대기시간 + 실행시간) / 실행시간**

### 데이터베이스 트랜잭션의 4가지 속성

> - **원자성**: 트랜잭션은 연산들을 전부 실행하든지 전혀 실행하지 않아야 한다. 일부만 실행해서는 안 된다.
> - **일관성**: 트랜잭션이 성공적으로 실행되면 데이터베이스 상태는 모순되지 않고 일관된 상태가 된다.
> - **독립성**: 트랜잭션 실행 도중의 연산 결과는 다른 트랜잭션에서 접근할 수 없다.
> - **지속성**: 트랜잭션이 성공했을 경우 영구적으로 반영되어야 한다.

### 랜드 어택

> 패킷의 출발지 주소(Address)나 포트(port)를 임의로 변경하여 출발지와 목적지 주소(또는 포트)를 동일하게 함으로써, 공격 대상 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격

### OSI 7계층 물리계층

> 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의한다. 단위(PDU)는 '비트'를 사용한다.

### LOC 기법 계산식

> **코드 줄 개수 / 개발자 인원수 \* 평균 개발 라인수**

### 애플리케이션 성능 측정 요소

> - **처리량**: 일정 시간 내에 애플리케이션이 처리하는 일의 양
> - **응답시간**: 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
> - **경과시간**: 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
> - **자원 사용률**: 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등

### 소프트웨어 모듈화

> 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것으로, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어진다. 모듈의 독립성을 높이기 위해서는 **결합도**는 약하게, **응집도**는 강하게 만들어야 한다.

### 데이터베이스 반정규화

> **시스템 성능 향상, 개발 및 운영 편의성** 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 **의도적으로 정규화 원칙을 위배하는 것**

### Fan-in

> **데이터가 들어오는 것**. 반대로, **Fan-out은 데이터가 나가는 것**.

### C언어 버블 정렬

```c
#include
void align(int a[ ]) {
int temp;
for (int i = 0; i < 4; i++) {
  for (int j=0; j < 4 - i; j++)  {
    if (a[j]> a[j+1]) {
      temp = a[j];
      a[j] = a[j+1];
      a[j+1] = temp;
    }
  }
}

main( ) {
    int a[ ] = { 85, 75, 50, 100, 95 };
    align(a);
     for (int i = 0; i < 5; i++) printf("%d ", a[i]);
}
```

- 출력 결과는 `50 75 85 95 100`

### C언어 `switch` 구문

```c
#include
main( ) {
   int c = 1;
   switch (3) {
      case 1: c += 3;
      case 2: c++;
      case 3: c = 0;
      case 4: c += 3;
      case 5: c -= 10;
      default: c--;
   }
   printf("%d", c);
}
```

- `break` 가 없으므로 `case 3:` 이후 전부 실행
- 정답은 `-8`

### Java

```java
public class Test {
   static int[ ] arr( ) {
     int a[ ] = new int[4];
     int b = a.length;
     for(int i = 0; i < b; i++)
        a[i] = i;
     return a;
  }

  public static void main(String[ ] args) {
     int a[ ] = arr( );
     for(int i = 0; i < a.length; i++)
        System.out.print(a[i] + " ");
  }
}
```

- 출력 결과는 `0 1 2 3`

### SQL 튜플 수 계산하기

> 학생 테이블에 전기과 학생이 50명, 전산과 학생이 100명, 전자과 학생이 50명 있다고 할 때, 다음 SQL문 ①, ②, ③의 실행 결과로 표시되는 튜플의 수를 쓰시오. (단, DEPT 필드는 학과를 의미)​

```sql
SELECT 학과 FROM 학생;
SELECT DISTINCT 학과 FROM 학생;
SELECT COUNT(DISTINCT 학과) FROM 학생 WHERE 학과='전산과';
```

1. `SELECT 학과 FROM 학생;` 은 모든 학과에 속한 학생들의 정보를 가져오므로, 총 학생 수 만큼의 튜플이 표시됩니다. 따라서 결과 튜플의 수는 150개입니다.
2. `SELECT DISTINCT 학과 FROM 학생;` 은 학과 정보의 중복을 제거하여 각 학과를 한 번씩만 표시합니다. 따라서 학과의 종류인 3개(전기과, 전산과, 전자과.에 대해 한 개의 튜플씩 표시되므로, 결과 튜플의 수는 3개입니다.
3. `SELECT COUNT(DISTINCT 학과) FROM 학생 WHERE 학과='전산과';` 문은 특정 조건(학과가 `'전산과'`)을 만족하는 학생들 중에서도 학과의 고유 수를 세는 쿼리입니다. 하지만 `COUNT(DISTINCT 학과)` 부분은 조건에 맞는 경우에 학과가 하나뿐이므로, 이 경우 고유 학과 수는 항상 1입니다. 따라서 결과 튜플의 수는 1개입니다.
